<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image + Audio to Video Creator</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            text-align: center;
            color: #5a5a5a;
        }
        .file-upload-area {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            background-color: #fafafa;
            border-radius: 5px;
        }
        .file-upload-area label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .file-upload-area input[type="file"] {
            display: block;
            margin: 10px auto;
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        #imageList, #audioName {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        .options {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #eee;
            background-color: #f9f9f9;
            border-radius: 5px;
        }
        .options label {
            display: inline-block;
            margin-right: 10px;
            font-weight: bold;
        }
        .options input[type="number"], .options input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 15px;
            width: 80px;
        }
         .options select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 15px;
        }
        button {
            display: block;
            width: 100%;
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 20px;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status, #progress {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #eee;
            background-color: #e9ecef;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
         #progressBarContainer {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden; /* Ensures the inner bar stays within bounds */
            height: 20px; /* Give the progress bar some height */
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            text-align: center;
            line-height: 20px; /* Vertically center text if needed */
            color: white;
            transition: width 0.4s ease; /* Smooth transition for width changes */
            border-radius: 5px; /* Match container radius */
        }
        #logOutput {
            margin-top: 20px;
            background-color: #222;
            color: #eee;
            padding: 15px;
            border-radius: 5px;
            max-height: 300px;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #downloadLink {
            display: none; /* Hidden initially */
            margin-top: 20px;
            padding: 10px;
            text-align: center;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
        }
        #downloadLink:hover {
            background-color: #218838;
        }
        .hidden {
             display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Image + Audio to Video Creator</h1>

        <div class="file-upload-area">
            <label for="imageFiles">Select Image Files (in order):</label>
            <input type="file" id="imageFiles" accept="image/*" multiple>
            <div id="imageList">No images selected.</div>
        </div>

        <div class="file-upload-area">
            <label for="audioFile">Select Audio File:</label>
            <input type="file" id="audioFile" accept="audio/*">
            <div id="audioName">No audio file selected.</div>
        </div>

        <div class="options">
             <h2>Video Options</h2>
             <label for="frameRate">Image Duration (seconds):</label>
             <input type="number" id="imageDuration" value="3" min="0.1" step="0.1">

             <label for="outputFormat">Output Format:</label>
             <select id="outputFormat">
                 <option value="mp4" selected>MP4</option>
                 <option value="webm">WEBM</option>
                 <option value="mov">MOV</option>
                 <option value="gif">GIF (No Audio)</option>
             </select>
             <br><br>
             <small>Note: Processing takes time, especially for many images or long audio. Your browser might become unresponsive.</small>
        </div>

        <button id="createVideoButton" disabled>Load FFmpeg & Create Video</button>

        <div id="status">Status: Idle</div>
        <div id="progress" class="hidden">
             Progress: 0%
             <div id="progressBarContainer">
                 <div id="progressBar"></div>
             </div>
        </div>
        <div id="logOutput">Logs will appear here...</div>
        <a id="downloadLink" href="#" download="output.mp4">Download Video</a>

    </div>

    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js" integrity="sha512-qgGXRDRqu+2aR/OBtmWzHhVfkf/b4Rk6bCGAkGdVpt1F1EWt7rC/4x2wV0U0kO5pL4F371b/J7B4cSmT5Qo4zg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpeg = null;

        const imageFilesInput = document.getElementById('imageFiles');
        const audioFileInput = document.getElementById('audioFile');
        const imageListDiv = document.getElementById('imageList');
        const audioNameDiv = document.getElementById('audioName');
        const createVideoButton = document.getElementById('createVideoButton');
        const statusDiv = document.getElementById('status');
        const progressDiv = document.getElementById('progress');
        const progressBar = document.getElementById('progressBar');
        const logOutputDiv = document.getElementById('logOutput');
        const downloadLink = document.getElementById('downloadLink');
        const imageDurationInput = document.getElementById('imageDuration');
        const outputFormatSelect = document.getElementById('outputFormat');

        let uploadedImages = [];
        let uploadedAudio = null;

        // --- Core FFmpeg Functions ---

        const getFFmpeg = async () => {
            if (ffmpeg) {
                return ffmpeg;
            }
            statusDiv.textContent = 'Status: Loading FFmpeg...';
            logOutputDiv.innerHTML = 'Loading FFmpeg core...\n';
            ffmpeg = new FFmpeg();

            ffmpeg.on('log', ({ message }) => {
                logOutputDiv.innerHTML += message + '\n';
                logOutputDiv.scrollTop = logOutputDiv.scrollHeight; // Auto-scroll
            });

            ffmpeg.on('progress', ({ progress, time }) => {
                const progressPercent = Math.round(progress * 100);
                progressDiv.classList.remove('hidden');
                progressDiv.firstChild.textContent = `Progress: ${progressPercent}%`;
                progressBar.style.width = `${progressPercent}%`;
                if (time) {
                    // Time is in microseconds
                    const seconds = (time / 1000000).toFixed(2);
                     progressDiv.firstChild.textContent += ` (Processed ${seconds}s)`;
                }
                 console.log('Progress:', { progress, time });
            });

            try {
                 // URLs for the core and worker scripts from unpkg CDN
                const coreURL = "https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js";
                // Single-threaded version doesn't strictly need workerURL, but providing it doesn't hurt.
                // For multi-threaded (@ffmpeg/core-mt), workerURL is essential.
                 // const wasmURL = "https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.wasm";
                 // const workerURL = "https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.worker.js";

                await ffmpeg.load({ coreURL }); // Pass CDN URLs
                statusDiv.textContent = 'Status: FFmpeg Loaded. Ready to process.';
                logOutputDiv.innerHTML += 'FFmpeg core loaded successfully.\n';
                createVideoButton.disabled = false; // Enable button after loading
                createVideoButton.textContent = 'Create Video';
            } catch (error) {
                statusDiv.textContent = 'Status: Error loading FFmpeg.';
                logOutputDiv.innerHTML += `Error loading FFmpeg: ${error}\n`;
                console.error("FFmpeg load error:", error);
                 createVideoButton.disabled = true;
                 createVideoButton.textContent = 'Error Loading FFmpeg';
            }
            return ffmpeg;
        };

        // Initialize FFmpeg on page load but don't block UI
        getFFmpeg();

        // --- Utility Functions ---
        const readFileAsArrayBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(new Uint8Array(reader.result));
                reader.onerror = (error) => reject(error);
                reader.readAsArrayBuffer(file);
            });
        };

        // --- Event Listeners ---

        imageFilesInput.addEventListener('change', (event) => {
            uploadedImages = Array.from(event.target.files);
             // Sort files by name to ensure order, assuming names like image01.jpg, image02.jpg etc.
            // A more robust solution might require user confirmation of order or a different UI.
            uploadedImages.sort((a, b) => a.name.localeCompare(b.name));
            if (uploadedImages.length > 0) {
                imageListDiv.textContent = `${uploadedImages.length} image(s) selected: ${uploadedImages.map(f => f.name).join(', ')}`;
            } else {
                imageListDiv.textContent = 'No images selected.';
            }
             checkEnableButton();
        });

        audioFileInput.addEventListener('change', (event) => {
            uploadedAudio = event.target.files[0];
            if (uploadedAudio) {
                audioNameDiv.textContent = `Audio selected: ${uploadedAudio.name}`;
            } else {
                audioNameDiv.textContent = 'No audio file selected.';
            }
            checkEnableButton();
        });

         function checkEnableButton() {
            // Enable the main button only if ffmpeg is loaded AND files are selected
             if (ffmpeg && ffmpeg.loaded && uploadedImages.length > 0 && (uploadedAudio || outputFormatSelect.value === 'gif')) {
                createVideoButton.disabled = false;
                 createVideoButton.textContent = 'Create Video';
            } else if (ffmpeg && !ffmpeg.loaded) {
                createVideoButton.disabled = true; // Keep disabled if ffmpeg isn't loaded yet
                 createVideoButton.textContent = 'Load FFmpeg & Create Video';
            } else {
                 createVideoButton.disabled = true;
                 createVideoButton.textContent = 'Select Files First';
            }
        }


        createVideoButton.addEventListener('click', async () => {
             if (!ffmpeg || !ffmpeg.loaded) {
                statusDiv.textContent = 'Status: FFmpeg not loaded yet.';
                return;
            }
             if (uploadedImages.length === 0) {
                statusDiv.textContent = 'Status: Please select image files.';
                return;
            }
             const outputFormat = outputFormatSelect.value;
             if (!uploadedAudio && outputFormat !== 'gif') {
                statusDiv.textContent = 'Status: Please select an audio file (or choose GIF format).';
                return;
            }

            createVideoButton.disabled = true;
            statusDiv.textContent = 'Status: Processing... Writing files to virtual memory.';
            logOutputDiv.innerHTML = 'Starting video creation...\n';
             progressDiv.classList.add('hidden'); // Reset progress bar display
             progressBar.style.width = '0%';
             downloadLink.style.display = 'none'; // Hide previous download link

            try {
                // 1. Write files to FFmpeg's virtual file system
                logOutputDiv.innerHTML += 'Writing image files...\n';
                for (let i = 0; i < uploadedImages.length; i++) {
                    const file = uploadedImages[i];
                    const data = await readFileAsArrayBuffer(file);
                    // Pad index for consistent naming (e.g., img001.png)
                     const paddedIndex = String(i + 1).padStart(3, '0');
                     const extension = file.name.split('.').pop() || 'png'; // Use original extension or default to png
                     const inputFilename = `img${paddedIndex}.${extension}`;
                    await ffmpeg.writeFile(inputFilename, data);
                    logOutputDiv.innerHTML += `Written: ${inputFilename}\n`;
                }

                 const audioInputFilename = 'input_audio'; // Base name, ffmpeg detects format
                 let audioExtension = '';
                 if (uploadedAudio) {
                    logOutputDiv.innerHTML += 'Writing audio file...\n';
                    const audioData = await readFileAsArrayBuffer(uploadedAudio);
                     audioExtension = uploadedAudio.name.split('.').pop() || 'mp3';
                    await ffmpeg.writeFile(`${audioInputFilename}.${audioExtension}`, audioData);
                    logOutputDiv.innerHTML += `Written: ${audioInputFilename}.${audioExtension}\n`;
                }

                statusDiv.textContent = 'Status: Running FFmpeg command...';
                logOutputDiv.innerHTML += 'Executing FFmpeg command...\n';

                // 2. Construct and Run FFmpeg Command
                const imageDuration = parseFloat(imageDurationInput.value) || 3;
                if (imageDuration <= 0) {
                     throw new Error("Image duration must be positive.");
                }
                const frameRate = 1 / imageDuration; // Calculate framerate based on duration

                const outputFilename = `output.${outputFormat}`;
                const args = [
                    '-framerate', `${frameRate}`, // Input framerate based on desired duration per image
                     '-i', 'img%03d.png', // Input image sequence pattern (assumes png, adjust if needed or analyze first image)
                ];

                 // Add audio input if present and format is not GIF
                 if (uploadedAudio && outputFormat !== 'gif') {
                    args.push('-i', `${audioInputFilename}.${audioExtension}`);
                }

                 // Add common output options
                if (outputFormat === 'mp4') {
                    args.push(
                        '-c:v', 'libx264',     // Video codec
                        '-preset', 'medium', // Encoding speed/quality trade-off
                        '-tune', 'stillimage', // Optimize for still images
                         '-crf', '23', // Constant Rate Factor (lower is higher quality, 18-28 is common)
                        '-pix_fmt', 'yuv420p'  // Pixel format for compatibility
                     );
                 } else if (outputFormat === 'webm') {
                     args.push(
                         '-c:v', 'libvpx-vp9', // VP9 codec for WebM
                         '-crf', '30',         // CRF for VP9 (adjust as needed)
                         '-b:v', '0',          // Needed for CRF mode with VP9
                         '-pix_fmt', 'yuv420p'
                     );
                 } else if (outputFormat === 'mov') {
                     args.push(
                         '-c:v', 'libx264',     // Use x264 for MOV as well (widely compatible)
                         '-preset', 'medium',
                         '-tune', 'stillimage',
                         '-crf', '23',
                         '-pix_fmt', 'yuv420p'
                     );
                 } else if (outputFormat === 'gif') {
                     // GIF specific settings - high quality often needs palette generation
                     args.push(
                         // Optional: Palette generation for better quality GIF
                         // This would require a two-pass approach which is more complex
                         // Simple direct conversion:
                          '-vf', 'fps=10,scale=320:-1:flags=lanczos', // Example filter: 10fps, 320px wide, lanczos scaling
                         '-loop', '0' // 0 for infinite loop, -1 for no loop, N for N+1 loops
                     );
                 }


                 // Add audio codec options if audio is used
                if (uploadedAudio && outputFormat !== 'gif') {
                    args.push(
                        '-c:a', 'aac',         // Audio codec (AAC is common)
                        '-b:a', '192k'       // Audio bitrate
                    );
                 } else if (outputFormat !== 'gif') {
                     // If no audio file provided but format supports audio, add silent audio
                     // This prevents issues with players expecting an audio track.
                      args.push('-f', 'lavfi', '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100');
                      args.push('-c:a', 'aac', '-b:a', '128k'); // Add silent audio track
                 }

                 // Use -shortest if audio is present to end video with audio
                 if (uploadedAudio && outputFormat !== 'gif') {
                     args.push('-shortest');
                 } else if (outputFormat !== 'gif') {
                     // If we added silent audio, we need to define its duration,
                     // which should match the total image duration.
                     const totalVideoDuration = uploadedImages.length * imageDuration;
                     args.push('-t', `${totalVideoDuration}`);
                 }


                args.push(outputFilename); // Output file

                logOutputDiv.innerHTML += `\nRunning: ffmpeg ${args.join(' ')}\n\n`;
                progressDiv.classList.remove('hidden'); // Show progress bar

                 // Execute the command
                await ffmpeg.exec(args);

                statusDiv.textContent = 'Status: Processing complete. Reading output file.';
                logOutputDiv.innerHTML += '\nFFmpeg command finished.\nReading output file...\n';

                // 3. Read the output file
                const outputData = await ffmpeg.readFile(outputFilename);

                // 4. Create download link
                const videoBlob = new Blob([outputData.buffer], { type: `video/${outputFormat === 'webm' ? 'webm' : outputFormat}` }); // Adjust MIME type if necessary
                const videoUrl = URL.createObjectURL(videoBlob);
                downloadLink.href = videoUrl;
                downloadLink.download = `video_output.${outputFormat}`;
                downloadLink.style.display = 'block'; // Show the download link

                statusDiv.textContent = 'Status: Video created successfully! Click link to download.';
                logOutputDiv.innerHTML += `Output file "${outputFilename}" created.\n`;

                 // Cleanup virtual files (optional, ffmpeg instance might clear on reload/new load)
                 try {
                     logOutputDiv.innerHTML += 'Cleaning up virtual files...\n';
                     for (let i = 0; i < uploadedImages.length; i++) {
                         const paddedIndex = String(i + 1).padStart(3, '0');
                         const extension = uploadedImages[i].name.split('.').pop() || 'png';
                         await ffmpeg.deleteFile(`img${paddedIndex}.${extension}`);
                     }
                     if (uploadedAudio) {
                          await ffmpeg.deleteFile(`${audioInputFilename}.${audioExtension}`);
                     }
                     await ffmpeg.deleteFile(outputFilename);
                      logOutputDiv.innerHTML += 'Cleanup complete.\n';
                 } catch (cleanupError) {
                     logOutputDiv.innerHTML += `Warning: Error during cleanup: ${cleanupError}\n`;
                 }


            } catch (error) {
                statusDiv.textContent = 'Status: Error during processing.';
                logOutputDiv.innerHTML += `\n--- ERROR ---\n${error}\n-------------\n`;
                console.error('FFmpeg processing error:', error);
            } finally {
                 // Re-enable button if ffmpeg is still loaded, regardless of success/failure
                 if (ffmpeg && ffmpeg.loaded) {
                     createVideoButton.disabled = false;
                     createVideoButton.textContent = 'Create Video';
                 } else {
                     createVideoButton.disabled = true; // Keep disabled if ffmpeg load failed earlier
                 }
                // Ensure progress bar is hidden if process finished quickly or failed early
                 // if (progressBar.style.width !== '100%') {
                 //    progressDiv.classList.add('hidden');
                 // }
            }
        });

    </script>
</body>
</html>