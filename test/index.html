<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image + Audio to Video Creator</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 80%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1, h2 {
            text-align: center;
            color: #5a5a5a;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        input[type="file"], input[type="number"], button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Important */
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #status, #logs, #progress {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #eee;
            background-color: #f9f9f9;
            border-radius: 4px;
            min-height: 50px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap; /* Keep line breaks */
            word-wrap: break-word;
            font-family: monospace;
            font-size: 14px;
        }
         #logs p, #progress p {
            margin: 0 0 5px 0;
            padding: 0;
        }
        #downloadLinkContainer {
            margin-top: 20px;
            text-align: center;
        }
        #downloadLink {
            display: inline-block;
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        #downloadLink:hover {
            background-color: #218838;
        }
        .file-info {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Image + Audio to Video Creator</h1>
        <p style="text-align: center;">This tool uses FFmpeg (compiled to WebAssembly) directly in your browser to create a video from your image sequence and an audio file.</p>

        <div>
            <label for="imageFiles">Select Image Files (in sequence order):</label>
            <input type="file" id="imageFiles" accept="image/*" multiple required>
            <div id="imageFileInfo" class="file-info">No images selected.</div>
        </div>

        <div>
            <label for="audioFile">Select Audio File:</label>
            <input type="file" id="audioFile" accept="audio/*" required>
             <div id="audioFileInfo" class="file-info">No audio file selected.</div>
        </div>

        <div>
            <label for="frameRate">Frame Rate (images per second):</label>
            <input type="number" id="frameRate" value="1" min="0.1" step="0.1" required>
        </div>

         <div>
            <label for="outputFormat">Output Video Format:</label>
            <select id="outputFormat" style="width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
                <option value="mp4">MP4 (H.264/AAC)</option>
                <option value="webm">WEBM (VP9/Opus)</option>
                <option value="gif">GIF (Animated)</option>
            </select>
        </div>

        <button id="createVideoButton" disabled>Load FFmpeg & Create Video</button>

        <h2>Status</h2>
        <div id="status">Ready. Select files and click the button.</div>

        <h2>Progress</h2>
        <div id="progress"><p>Waiting for process to start...</p></div>

        <h2>FFmpeg Logs</h2>
        <div id="logs"><p>FFmpeg output will appear here...</p></div>

        <div id="downloadLinkContainer" style="display: none;">
            <a id="downloadLink" href="#" download="output.mp4">Download Video</a>
        </div>
    </div>

    <script src="./ffmpeg/node_modules/@ffmpeg/ffmpeg/dist/umd/ffmpeg.js"></script>

    <script>
        // DOM Elements
        const imageFilesInput = document.getElementById('imageFiles');
        const audioFileInput = document.getElementById('audioFile');
        const frameRateInput = document.getElementById('frameRate');
        const outputFormatSelect = document.getElementById('outputFormat');
        const createVideoButton = document.getElementById('createVideoButton');
        const statusDiv = document.getElementById('status');
        const logsDiv = document.getElementById('logs');
        const progressDiv = document.getElementById('progress');
        const downloadLinkContainer = document.getElementById('downloadLinkContainer');
        const downloadLink = document.getElementById('downloadLink');
        const imageFileInfoDiv = document.getElementById('imageFileInfo');
        const audioFileInfoDiv = document.getElementById('audioFileInfo');

        let ffmpegInstance = null;
        let ffmpegLoaded = false;

        // --- FFmpeg Initialization ---

        async function initializeFFmpeg() {
            statusDiv.textContent = 'Initializing FFmpeg... This might take a moment.';
            logsDiv.innerHTML = '<p>Loading FFmpeg core...</p>'; // Clear previous logs
            progressDiv.innerHTML = '<p>Waiting for FFmpeg load...</p>'; // Clear previous progress

            try {
                // IMPORTANT: Paths to core components within your 'ffmpeg' folder.
                // Adjust these paths if your folder structure on GitHub Pages is different.
                const corePath = './ffmpeg/node_modules/@ffmpeg/core/dist/umd/ffmpeg-core.js';
                const wasmPath = './ffmpeg/node_modules/@ffmpeg/core/dist/umd/ffmpeg-core.wasm';
                // Note: If you used @ffmpeg/core-mt (multithreaded), you'd also need workerPath.
                // const workerPath = './ffmpeg/node_modules/@ffmpeg/core-mt/dist/umd/ffmpeg-core.worker.js';

                // Check if FFmpeg class is available (loaded from the script tag)
                if (typeof FFmpegWASM === 'undefined' || typeof FFmpegWASM.FFmpeg === 'undefined') {
                     throw new Error('FFmpeg library script not loaded correctly. Check the script tag path.');
                }
                 const { FFmpeg } = FFmpegWASM;

                ffmpegInstance = new FFmpeg();

                // Set up logging and progress handlers
                ffmpegInstance.on('log', ({ type, message }) => {
                    const logElement = document.createElement('p');
                    logElement.textContent = `[${type}] ${message}`;
                    logsDiv.appendChild(logElement);
                    logsDiv.scrollTop = logsDiv.scrollHeight; // Auto-scroll
                    console.log(`FFmpeg Log (${type}):`, message);
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                    const progressPercent = progress * 100;
                    const timeInSeconds = time / 1000000; // Time is in microseconds
                    const progressElement = document.createElement('p');
                    progressElement.textContent = `Progress: ${progressPercent.toFixed(2)}% (Processed Time: ${timeInSeconds.toFixed(2)}s)`;
                    progressDiv.innerHTML = ''; // Clear previous progress message
                    progressDiv.appendChild(progressElement);
                    console.log(`FFmpeg Progress: ${progressPercent.toFixed(2)}%, Time: ${timeInSeconds.toFixed(2)}s`);
                });

                // Load the core
                logsDiv.innerHTML += '<p>Starting FFmpeg.load()...</p>';
                statusDiv.textContent = 'Loading FFmpeg core (JS/WASM)...';
                await ffmpegInstance.load({
                    coreURL: corePath,
                    wasmURL: wasmPath,
                    // workerURL: workerPath, // Only needed for core-mt
                });

                ffmpegLoaded = true;
                statusDiv.textContent = 'FFmpeg loaded successfully. Ready to create video.';
                logsDiv.innerHTML += '<p>FFmpeg core loaded.</p>';
                checkInputsAndEnableButton(); // Re-check if files were selected before load finished

            } catch (error) {
                ffmpegLoaded = false;
                statusDiv.textContent = `Error loading FFmpeg: ${error.message}`;
                logsDiv.innerHTML += `<p style="color: red;">Error loading FFmpeg: ${error}</p>`;
                console.error("FFmpeg loading error:", error);
                createVideoButton.disabled = true; // Keep disabled on error
            }
        }

        // --- File Handling and UI ---

        function checkInputsAndEnableButton() {
            const imagesSelected = imageFilesInput.files && imageFilesInput.files.length > 0;
            const audioSelected = audioFileInput.files && audioFileInput.files.length > 0;

            // Update file info display
            imageFileInfoDiv.textContent = imagesSelected ? `${imageFilesInput.files.length} image(s) selected.` : 'No images selected.';
            audioFileInfoDiv.textContent = audioSelected ? `Audio: ${audioFileInput.files[0].name}` : 'No audio file selected.';

            // Enable button only if FFmpeg is loaded AND files are selected
            createVideoButton.disabled = !(ffmpegLoaded && imagesSelected && audioSelected);
        }

        // Utility to read file as ArrayBuffer
        const readFileAsArrayBuffer = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve(new Uint8Array(event.target.result));
                reader.onerror = (error) => reject(error);
                reader.readAsArrayBuffer(file);
            });
        };

        // Event listeners for file inputs
        imageFilesInput.addEventListener('change', checkInputsAndEnableButton);
        audioFileInput.addEventListener('change', checkInputsAndEnableButton);

        // --- Video Creation Logic ---

        createVideoButton.addEventListener('click', async () => {
            if (!ffmpegLoaded || !ffmpegInstance) {
                statusDiv.textContent = 'FFmpeg is not loaded. Please wait or reload.';
                return;
            }
            if (imageFilesInput.files.length === 0 || audioFileInput.files.length === 0) {
                 statusDiv.textContent = 'Please select image files and an audio file.';
                 return;
            }

            createVideoButton.disabled = true;
            statusDiv.textContent = 'Starting video creation process...';
            logsDiv.innerHTML = '<p>Process started...</p>'; // Clear previous logs
            progressDiv.innerHTML = '<p>Preparing files...</p>'; // Clear previous progress
            downloadLinkContainer.style.display = 'none'; // Hide previous download link

            try {
                const imageFiles = Array.from(imageFilesInput.files).sort((a, b) => a.name.localeCompare(b.name)); // Ensure order
                const audioFile = audioFileInput.files[0];
                const frameRate = frameRateInput.value;
                const outputFormat = outputFormatSelect.value;
                const outputFilename = `output.${outputFormat}`;

                // 1. Write files to FFmpeg's virtual file system
                statusDiv.textContent = 'Writing image files to virtual system...';
                logsDiv.innerHTML += `<p>Writing ${imageFiles.length} images...</p>`;
                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    const data = await readFileAsArrayBuffer(file);
                    // Pad index for consistent naming (e.g., img001.png, img002.png)
                    const paddedIndex = String(i + 1).padStart(3, '0');
                    const filename = `img${paddedIndex}.png`; // Assuming PNG, adjust if needed
                    await ffmpegInstance.FS('writeFile', filename, data);
                    logsDiv.innerHTML += `<p>Written: ${filename}</p>`;
                }

                statusDiv.textContent = 'Writing audio file to virtual system...';
                logsDiv.innerHTML += `<p>Writing audio: ${audioFile.name}</p>`;
                const audioData = await readFileAsArrayBuffer(audioFile);
                const audioFilename = 'audio.' + audioFile.name.split('.').pop(); // Get extension
                await ffmpegInstance.FS('writeFile', audioFilename, audioData);
                logsDiv.innerHTML += '<p>All input files written.</p>';


                // 2. Construct FFmpeg command arguments
                // Example command: ffmpeg -framerate 1 -i img%03d.png -i audio.mp3 -c:v libx264 -tune stillimage -c:a aac -b:a 192k -pix_fmt yuv420p -shortest output.mp4
                const args = [];
                args.push('-framerate', frameRate);
                args.push('-i', 'img%03d.png'); // Input image sequence pattern
                args.push('-i', audioFilename);  // Input audio file

                // Output settings based on format
                switch (outputFormat) {
                    case 'mp4':
                        args.push('-c:v', 'libx264');     // Video codec
                        args.push('-tune', 'stillimage'); // Optimize for still images
                        args.push('-c:a', 'aac');         // Audio codec
                        args.push('-b:a', '192k');        // Audio bitrate
                        args.push('-pix_fmt', 'yuv420p'); // Pixel format for compatibility
                        break;
                    case 'webm':
                         args.push('-c:v', 'libvpx-vp9'); // Video codec (VP9)
                         args.push('-crf', '30');         // Constant Rate Factor (quality, lower is better)
                         args.push('-b:v', '0');          // Needed for CRF mode
                         args.push('-c:a', 'libopus');    // Audio codec (Opus)
                         args.push('-b:a', '128k');       // Audio bitrate
                         break;
                    case 'gif':
                         // GIF creation often involves a palette generation step first for better quality,
                         // but for simplicity, we'll do a direct conversion.
                         // You might need to adjust filters for better results (e.g., fps, scale).
                         args.push('-vf', `fps=${frameRate},scale=w=480:h=-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`); // Example filter for GIF
                         args.push('-loop', '0'); // 0 for infinite loop
                         // No audio for GIF
                         args.pop(); // Remove audio input
                         args.pop();
                         break;
                    default:
                        throw new Error(`Unsupported output format: ${outputFormat}`);
                }


                // Add '-shortest' only if it's not GIF (GIF doesn't have audio duration to match)
                 if (outputFormat !== 'gif') {
                    args.push('-shortest'); // End video when the shortest input (images or audio) ends
                 }
                args.push(outputFilename); // Output file name

                statusDiv.textContent = 'Executing FFmpeg command...';
                logsDiv.innerHTML += `<p>Running command: ffmpeg ${args.join(' ')}</p>`;
                progressDiv.innerHTML = '<p>Processing...</p>';

                // 3. Execute the command
                await ffmpegInstance.exec(args);

                statusDiv.textContent = 'FFmpeg command finished. Reading output file...';
                logsDiv.innerHTML += '<p>Execution complete.</p>';

                // 4. Read the output file
                const outputData = await ffmpegInstance.FS('readFile', outputFilename);

                statusDiv.textContent = 'Video created successfully!';
                logsDiv.innerHTML += `<p>Output file "${outputFilename}" read successfully.</p>`;

                // 5. Create download link
                const blob = new Blob([outputData.buffer], { type: outputFormat === 'mp4' ? 'video/mp4' : (outputFormat === 'webm' ? 'video/webm' : 'image/gif') });
                const url = URL.createObjectURL(blob);
                downloadLink.href = url;
                downloadLink.download = outputFilename;
                downloadLinkContainer.style.display = 'block'; // Show download link


                // 6. Clean up virtual file system (optional but good practice)
                logsDiv.innerHTML += '<p>Cleaning up virtual files...</p>';
                 try {
                    for (let i = 0; i < imageFiles.length; i++) {
                         const paddedIndex = String(i + 1).padStart(3, '0');
                         await ffmpegInstance.FS('unlink', `img${paddedIndex}.png`);
                    }
                     await ffmpegInstance.FS('unlink', audioFilename);
                     await ffmpegInstance.FS('unlink', outputFilename);
                     logsDiv.innerHTML += '<p>Cleanup complete.</p>';
                 } catch(cleanupError) {
                    logsDiv.innerHTML += `<p style="color: orange;">Warning during cleanup: ${cleanupError}</p>`;
                 }


            } catch (error) {
                statusDiv.textContent = `Error during video creation: ${error}`;
                logsDiv.innerHTML += `<p style="color: red;">Error: ${error}</p>`;
                console.error("Video creation error:", error);
            } finally {
                // Re-enable button if FFmpeg is still loaded
                createVideoButton.disabled = !ffmpegLoaded;
                 // Ensure progress shows completion or last status
                 if (!statusDiv.textContent.includes('Error') && !statusDiv.textContent.includes('successfully')) {
                    progressDiv.innerHTML = '<p>Process ended.</p>';
                 } else if (statusDiv.textContent.includes('successfully')) {
                     progressDiv.innerHTML = '<p>Done.</p>';
                 }

            }
        });

        // --- Initial Load Trigger ---
        // Automatically start loading FFmpeg when the page loads.
        // Alternatively, you could trigger this with the button click
        // if you prefer lazy loading.
        document.addEventListener('DOMContentLoaded', initializeFFmpeg);

    </script>

</body>
</html>